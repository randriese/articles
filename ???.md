# Title

I've been doing Vue, professionally, for a while now. As usual, whenever I create/setup a new project, I use Vue CLI which abstracts a lot of the heavy weight of creating a new project, which is great, especially if you've ever tried to setup a full Webpack config by yourself.
Nonetheless, I want to walk through the process of setuping a Webpack config by myself and highlight some benefits and drawbacks of using Vue CLI on the way. I will try to mimic as much as possible the behavior of Vue CLI but avoid the usage of its plugins for example.

Why I want to do that? Wel, as sort of documentation/study for myself (I can't remember the last time I went through each Webpack loader and customized it, which is great, don't get me wrong) and also to, maybe, help to people to understand the full process and challenges that comes with such setup (so you might get some feeling about why Vue CLI does a great job for us).

I will try to split it between Webpack, Vue and enhancements. First I will go through Webpack, simple and direct setup, what does it do and so on (the Webpack docs do a great job here). Second I will setup Vue with Wepack, so it can understand `*.vue` files. And finally I will add some things to make our lives easier (hopefully).

## Webpack

Most probably you've heard about Webpack before, if not, check their [official website](https://webpack.js.org) which has tons of documentation about it.

I think this image, from the offical website, summarizes quite well what Webpack does for us:

![Webpack bundle process](https://i.ibb.co/Yyw2L2v/image-1.png)

Once you start reading the documentation you will find out that the first two dependencies you've to install are `webpack` and `webpack-cli`. From here we can start customizing our Webpack config.

The Webpack config starts with the `entry` property, which specifies the entry file to process with Webpack. Once we setup a project with Vue CLI it always points to `main.js` inside the `src/` folder.

```javascript
module.exports = {
  entry: './src/main.js',
};
```

If we add any Javascript code to `main.js` it will get processed by Webpack and the output will be placed inside `dist/` folder. To run Webpack we just need to `npx webpack --config webpack.config.js`.

First thing it complains (warns) is regarding the `mode` property which was not set.

From Webpack docs:
> Providing the `mode` configuration option tells webpack to use its built-in optimizations accordingly.

It can be `production`, `development` or `none`.

A good start now is to setup NPM scripts with our build steps, so we can build our project for production, development, or something else.

```json
"scripts": {
  "build:production": "webpack --config webpack.config.js --mode=production",
  "build:development": "webpack --config webpack.config.js --mode=development"
}
```

So far we can add Javascript code to `src/main.js` file and build it. Not that useful, but it is the basic setup.

### Loaders

From the docs:

> webpack enables use of loaders to preprocess files. This allows you to bundle any static resource way beyond JavaScript.

Loaders are the magic behind Webpack. They allow us to process different file types in different ways and the outcome will be a single (or multiple) bundled file.

One concern that we usually have when developing is: it should work cross browser. Which means, it should fallback features that are not present in old browsers. A project that does this kind of job is [Babel](https://babel.dev) and we can, via loader, use it with Webpack. We can tell Webpack to process Javascript files with Babel, which will do the job of compiling our code.

To use Babel with Webpack we need to setup its [loader](https://github.com/babel/babel-loader). From the Babel loader docs we endup with the following Webpack config:

```javascript
module.exports = {
  entry: './src/main.js',
  module: {
    rules: [{
      test: /\.js$/,
      exclude: /node_modules/,
      use: {
        loader: 'babel-loader',
      },
    }],
  },
};
```

Let's take a step back and run things. First, if the `main.js` file contained something that doesn't need to be compiled, it won't make a huge difference here. For example, if you write `console.log('Hello World!')` in the `main.js` file, the output will be similar without the loader.

It gets more interesting once we started adding features that are not supported in all browsers. First lets setup Babel configuration file, also known as `babelrc`, which allows us to use special syntax if we want or use the well known [`@babel/preset-env`](https://babeljs.io/docs/en/babel-preset-env) which:

> is a smart preset that allows you to use the latest JavaScript without needing to micromanage which syntax transforms (and optionally, browser polyfills) are needed by your target environment(s). This both makes your life easier and JavaScript bundles smaller!

The setup needed is the following:

```json
{
  "presets": ["@babel/preset-env"]
}
```

Now our project is ready to compile "new" Javascript syntax. Let's take the following code as example:

```javascript
async function hey() {
  await Promise.resolve();

  return 'Hey!';
}

hey();
```

It uses a new syntax that won't work in old browsers. If we build our file without the Babel config, the output will be something like the following:

```javascript
eval("async function hey() {\n  await Promise.resolve();\n  return 'Hey!';\n}\n\nhey();\n\n//# sourceURL=webpack:///./src/main.js?");
```

If we setup the Babel config file, the output will be like:

```javascript
eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction hey() {\n  return _hey.apply(this, arguments);\n}\n\nfunction _hey() {\n  _hey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.resolve();\n\n          case 2:\n            return _context.abrupt(\"return\", 'Hey!');\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _hey.apply(this, arguments);\n}\n\nhey();\n\n//# sourceURL=webpack:///./src/main.js?");
```

Ok, let's break it into smaller pieces first. The first code is basically a copy and paste from the code we wrote. The second one has some magic so we don't see the usage of `async/await` for example. `@babel/preset-env` is doing its job here, we didn't need to tell it that we would be using a specific feature. Now the question that you might be asking is: what happens if I want to support only browsers that support `async/await`?

The answer is: [Browserslist](https://github.com/browserslist/browserslist). You might have seen a file called `.browserslistrc` in the root of a project or inside `package.json`. This file is responsible for specifying which browsers you want to support and is used by multiple tools to bundle your code. Babel is one of them. If you run `npx browserslist` in your project you will see a list of browsers it should support. By default, at the time of this writing, the list is the following (which is the `defaults` setting from `browserslist`):

```
and_chr 81
and_ff 68
and_qq 10.4
and_uc 12.12
android 81
baidu 7.12
chrome 83
chrome 81
chrome 80
edge 83
edge 81
edge 18
firefox 78
firefox 77
firefox 76
firefox 68
ie 11
ios_saf 13.4-13.5
ios_saf 13.3
ios_saf 12.2-12.4
kaios 2.5
op_mini all
op_mob 46
opera 69
opera 68
safari 13.1
safari 13
samsung 12.0
samsung 11.1-11.2
```

What we can do here is to setup our own `.browserslistrc` file with modern browsers, for example `last 2 Chrome versions`, and run our build again. The output will be the following:

```javascript
eval("async function hey() {\n  await Promise.resolve();\n  return 'Hey!';\n}\n\nhey();\n\n//# sourceURL=webpack:///./src/main.js?");
```

As the last 2 versions of Chrome support `async/await`, Babel won't transpile it so we will endup with "modern" code. As a side note, if you're not 100% sure of the browsers you need to support and so on, leave the default values and don't mess with your bundle.

Now that we know how to process a input file and do some kind of transformation with it, let's dig into Webpack plugins, the last part of the Webpack fundamentals (for this article).

### Plugins

Plugins do what loaders can't do. Ok, not that easy to understand but they hook into Webpack's lifecycle and do something. Webpack itself has a broad list of [plugins](https://webpack.js.org/plugins/) that you can choose and each of them add a specific "power" to your build.

Let's take the example from Vue CLI, the environment variables. You can define some environment variables, they should begin with `VUE_APP`, and they will be available inside your application.

If we want to do something similar, let's say we want to define `BASE_URL` as an environment variable, we need to use a plugin for that. Webpack provides a plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/) which `allows you to create global constants which can be configured at compile time.`.

The Webpack config will look like:

```javascript
plugins: [
  new webpack.DefinePlugin({
    'process.env': {
      BASE_URL: JSON.stringify('localhost'),
    },
  }),
],
```

Now we can use `process.env.BASE_URL` inside our code and it will be replaced by `'localhost'`. Vue CLI does an extra job and allows you to define `.env` files which is out of scope for now.

### Final config

This last part is to share the final Webpack configuration with everything in place. So far we will process the file `src/main.js`, it will use the DefinePlugin to replace `process.env.BASE_URL` by `'localhost'` and it will be processed by Babel which will take into account our `.browserslistrc` definition to add (or not) missing features.

```javascript
const webpack = require('webpack');

module.exports = {
  entry: './src/main.js',
  module: {
    rules: [{
      test: /\.js$/,
      exclude: /node_modules/,
      use: {
        loader: 'babel-loader',
      },
    }],
  },
  plugins: [
    new webpack.DefinePlugin({
      'process.env': {
        BASE_URL: JSON.stringify('localhost'),
      },
    }),
  ],
};
```

That is the basic of Webpack setup. You can imagine the heavy lift Vue CLI does and I hope we can understand a bit better how things work under the hood. Now let's write some `.vue` files!

## Using Vue with Webpack

We want to write `.vue` files and load them. From what we previously saw we will need a loader that is able to process this kind of file for us. Vue provides us with `vue-loader` which does the job. The [documentation](https://vue-loader.vuejs.org/guide) is really good and I recommend you to read it. First we need to install the following dependencies `vue-loader` and `vue-template-compiler`. After that we need to setup our loader to process `.vue` files with `vue-loader`:

```javascript
module: {
  rules: [
    {
      test: /\.vue$/,
      loader: 'vue-loader',
    },
  ],
},
```

We also need to use the Vue loader plugin, the reason for that is highlighted in the docs:

> It is responsible for cloning any other rules you have defined and applying them to the corresponding language blocks in .vue files. For example, if you have a rule matching /\.js$/, it will be applied to <script> blocks in .vue files.

```javascript
const VueLoaderPlugin = require('vue-loader/lib/plugin');

module.exports = {
  ...,
  plugins: [
    new VueLoaderPlugin(),
  ],
};
```

Now you might be asking, why did we install `vue-template-compiler` if we haven't used anywhere? The reason for that is because it is imported by default in the [loader options](https://vue-loader.vuejs.org/options.html#compiler). The compiler itself also supports some [options](https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#options) if we want to customize it.

We can now write our first `.vue` file and import it in our `main.js` file. I will use the following file, named `App.vue`, as example:

```vue
<template>
<h1>Hello world!</h1>
</template>

<script>
export default {
  name: 'App',
};
</script>
```

It will build as we expect but the outcome is not that interesting. Let's install Vue and load our built file in an `index.html` file so we can open it in the browser and see the above template running.

First we install Vue and import in our `main.js` file. Second we create an `index.html` file which uses the built `main.js` file as entry:

```html
<html>
  <head>
  </head>
  <body>
    <div id="app"></div>
    <script src="./dist/main.js"></script>
  </body>
</html>
```

Last we mount `App.vue` inside the `<div>` adding the following code to `main.js`:

```javascript
import Vue from 'vue';
import App from './App.vue';

new Vue({
  render: (h) => h(App),
}).$mount('#app');
```

Now if we build our application and serve it, we will see the `Hello world!` in our browser.

From Vue Loader docs we can find a lot of "extras" to apply to our build. For example Typescript, PostCSS and so on. Let's explore one example using PostCSS.

### Adding a custom Pre-Processor

As mentioned before, we are going to play with PostCSS. First we need to be able to process CSS, or the `<style>` inside a `.vue` file. In order to do so we will use two loaders: [`style-loader`](https://webpack.js.org/loaders/style-loader/) and [`css-loader`](https://webpack.js.org/loaders/css-loader/).

The `style-loader`:

> Inject CSS into the DOM.

And the `css-loader`:

> The css-loader interprets @import and url() like import/require() and will resolve them.

We need to add these loaders to our Webpack config file, it will be added like:

```javascript
{
  test: /\.css$/,
  use: [
    'style-loader',
    'css-loader',
  ],
},
```

Now things started to get a bit different from what we had before. The first thing to notice is: we're adding two loaders to the same file type. How does it work?
The order of execution is from the bottom to the top. In our example, first `css-loader` will do its job and afterwards `style-loader` will kick in. Which means that first we will be able to process the `<style>` from our `.vue` file and afterwards `style-loader` will inject the output into the DOM.

We're ready to add PostCSS. PostCSS allows us to do some transformations in our CSS, adding vendor prefixes (popular usage) for example. PostCSS has its own [loader](https://webpack.js.org/loaders/postcss-loader/) as well. First let's install and setup it in our Webpack config:

```javascript
{
  test: /\.css$/,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 1,
      },
    },
    'postcss-loader',
  ],
},
```

If you want to know more about the custom setup on `css-loader`, you can read about it [here](https://webpack.js.org/loaders/css-loader/#importloaders).

Now we need to setup a PostCSS config file. First let's just create a `postcss.config.js` and add `module.exports = {}` to it. Now we can build our project again.

PostCSS has tons of plugins to add transformations to our CSS and Autoprefixer is one of them. It automatically adds vender prefixes to our CSS.

Let's add some CSS that would require autoprefixing, like `transform: scale(0.5)`, for example. Now we need to install `autoprefixer` and add it to `postcss.config.js`. The final config will look like:

```javascript
const autoprefixer = require('autoprefixer');

module.exports = {
  plugins: [
    autoprefixer,
  ],
};
```

If we build our project now, assuming we kept the same setup from the first part of this walkthrough, nothing will change. It happens because PostCSS uses [browserslist](https://github.com/postcss/autoprefixer#browsers) to know which browsers you support so it doesn't need to add prefix for everything. Before we were supporting the last 2 versions of Chrome, which do not require autoprefixing `transform`. If we edit our `.browserslistrc` file to `IE 9`, for example, and build our project again we will find `-ms-transform` in the generated CSS.

Now we're finally ready with our PostCSS setup. We can add various different plugins and so on to it. We can also leverage the usage of `browserslist` when building our CSS.

The next part is all about adding different flavors to our setup. We're already ready to develop and so on but the experience is not the best: we are building our application manually every time; we are not optimizing anything; we do not autoinject the built file to our HTML... There are a lot of improvements that we can make.
